# 后端 500 错误排查指南

> 📅 创建时间：2025-10-09  
> 🔧 问题：后端返回 500 Internal Server Error  
> 🎯 前端状态：已修复完成，容错机制正常

---

## 📊 当前状态

### ✅ 前端（已完成）

| 检查项 | 状态 |
|--------|------|
| 网络连接 | ✅ 正常（能访问公网地址）|
| API 路径格式 | ✅ 正确（无重复路径）|
| 环境配置 | ✅ 完成（开发用公网，生产用内网）|
| 容错机制 | ✅ 已实现（加载失败时显示备用数据）|

**前端请求的 URL（正确）**：
```
✅ https://yjsp-ytg-191595-4-1367462091.sh.run.tcloudbase.com/api/v1/categories
✅ https://yjsp-ytg-191595-4-1367462091.sh.run.tcloudbase.com/api/v1/recipes?page=1&limit=10
```

### ❌ 后端（需要修复）

| 检查项 | 状态 |
|--------|------|
| 服务运行 | ✅ 正常（能返回 JSON）|
| 接口实现 | ❌ **500 错误** |
| 数据库连接 | ❓ 未知（需要查看日志）|
| 表结构 | ❓ 未知（需要查看日志）|

**后端返回的错误**：
```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

---

## 🔍 错误诊断

### 完整的错误信息

```bash
GET https://yjsp-ytg-191595-4-1367462091.sh.run.tcloudbase.com/api/v1/categories
Status: 500 (Internal Server Error)

Response:
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

### 错误类型分析

**500 Internal Server Error** 说明：
- ✅ 前端能访问后端（网络通畅）
- ✅ API 路径正确（后端能接收到请求）
- ❌ 后端在处理请求时出错了

---

## 🎯 可能的原因

### 1️⃣ 数据库连接失败（最可能）

**问题**：
- SQLPub 数据库配置错误
- 数据库连接字符串不正确
- 数据库服务未启动

**检查方法**：
```bash
# 查看后端环境变量
DATABASE_URL=mysql://user:password@host:port/database

# 测试数据库连接
mysql -h host -u user -p database
```

### 2️⃣ 数据表未创建

**问题**：
```sql
-- 后端代码尝试查询表，但表不存在
SELECT * FROM categories;  -- Error: Table 'categories' doesn't exist
```

**解决方法**：
```sql
-- 创建必要的数据表
CREATE TABLE categories (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  icon VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE recipes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  cover_image VARCHAR(255),
  -- ... 其他字段
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 3️⃣ 后端接口未完全实现

**问题**：
```typescript
// 后端代码可能只是个框架，没有实际实现
@Get('categories')
async getCategories() {
  // TODO: 实现获取分类列表
  throw new Error('Not implemented yet');  // 导致 500 错误
}
```

**解决方法**：
实现完整的接口逻辑

### 4️⃣ 后端代码有 bug

**常见的 bug**：
```typescript
// 空指针错误
const data = await this.categoryService.findAll();
const result = data.items.map(...)  // Error: data is undefined

// 类型错误
const page = req.query.page;
const offset = (page - 1) * 10;  // Error: page is string, not number

// 数据库查询错误
const result = await db.query('SELECT * FORM categories');  // Syntax error: FORM → FROM
```

### 5️⃣ 缺少必要的环境变量

**问题**：
```bash
# 后端可能缺少这些环境变量
DATABASE_URL=?
JWT_SECRET=?
WECHAT_APP_ID=?
WECHAT_APP_SECRET=?
```

---

## 🛠️ 排查步骤

### 步骤 1：查看后端日志

**在微信云托管控制台**：

1. 登录微信公众平台
2. 进入「云开发」→「云托管」
3. 选择你的服务
4. 点击「日志」查看

**查找关键信息**：
```bash
# 数据库错误
Error: connect ECONNREFUSED
Error: ER_NO_SUCH_TABLE: Table 'xxx' doesn't exist
Error: Access denied for user 'xxx'@'xxx'

# 代码错误
TypeError: Cannot read property 'xxx' of undefined
ReferenceError: xxx is not defined
Error: xxx is not a function

# 环境变量错误
Error: DATABASE_URL is not defined
Error: Missing required environment variable
```

### 步骤 2：检查数据库连接

**登录 SQLPub 管理面板**：

1. 检查数据库是否创建
2. 检查表结构是否存在
3. 检查数据是否初始化

**测试连接**：
```bash
# 使用 MySQL 客户端测试
mysql -h <SQLPub主机> -u <用户名> -p

# 查看数据库
SHOW DATABASES;

# 使用数据库
USE your_database;

# 查看表
SHOW TABLES;

# 查看表结构
DESCRIBE categories;
DESCRIBE recipes;
```

### 步骤 3：检查后端环境变量

**在云托管控制台**：

1. 进入「服务管理」
2. 点击「环境变量」
3. 检查是否配置了：
   - `DATABASE_URL`
   - `DATABASE_HOST`
   - `DATABASE_PORT`
   - `DATABASE_USER`
   - `DATABASE_PASSWORD`
   - `DATABASE_NAME`

### 步骤 4：本地测试后端

**如果你有后端代码**：

```bash
# 1. 克隆后端代码
git clone <后端仓库>

# 2. 安装依赖
npm install

# 3. 配置环境变量
cp .env.example .env
# 编辑 .env 文件，填入数据库配置

# 4. 运行后端
npm run dev

# 5. 测试接口
curl http://localhost:3000/api/v1/categories
```

### 步骤 5：联系后端开发者

如果以上步骤无法解决，联系后端开发者并提供：

1. **错误截图**（包含请求 URL 和响应）
2. **后端日志**（从云托管控制台复制）
3. **数据库配置**（脱敏后的连接信息）

---

## 📝 临时解决方案

### 前端已有容错机制

即使后端返回 500 错误，前端也不会白屏！

**1. 备用数据（Fallback Data）**

前端已经内置了备用数据：

```javascript
// pages/index/index.js
loadCoreData() {
  try {
    // 尝试从后端加载
    const data = await api.category.getCategoryList()
    this.setData({ categories: data })
  } catch (error) {
    // 后端失败，使用备用数据
    this.setData({ 
      categories: this.getDefaultCategories(),  // 内置的默认分类
      recommendRecipes: this.data.fallbackRecipes  // 内置的默认食谱
    })
  }
}
```

**2. 缓存机制**

分类数据会缓存 30 分钟：

```javascript
// api/category.js
getCategoryListCached() {
  // 优先使用缓存
  const cached = wx.getStorageSync('category_list')
  if (cached && !expired) {
    return cached.data  // 返回缓存数据
  }
  
  // 缓存失效，尝试从后端加载
  try {
    const data = await this.getCategoryList()
    // 更新缓存
    wx.setStorageSync('category_list', data)
    return data
  } catch (error) {
    // 后端失败，返回过期的缓存（总比没有好）
    if (cached) return cached.data
    throw error
  }
}
```

**3. 用户提示**

加载失败时会显示提示：

```javascript
wx.showToast({
  title: '加载失败，显示备用数据',
  icon: 'none'
})
```

### 用户体验

即使后端 500 错误，用户看到的是：
- ✅ 页面正常显示（使用备用数据）
- ✅ 可以浏览默认食谱
- ✅ 可以使用其他功能（收藏、搜索等基于本地存储的功能）
- ⚠️ 提示「加载失败」

---

## 🎯 后端开发建议

### 数据库初始化脚本

创建 `database/init.sql`：

```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS cooktip CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE cooktip;

-- 分类表
CREATE TABLE IF NOT EXISTS categories (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  icon VARCHAR(255),
  order_index INT DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_order (order_index)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 插入默认分类
INSERT INTO categories (name, icon, order_index) VALUES
('早餐', 'breakfast.png', 1),
('午餐', 'lunch.png', 2),
('晚餐', 'dinner.png', 3),
('甜点', 'dessert.png', 4),
('汤羹', 'soup.png', 5);

-- 食谱表
CREATE TABLE IF NOT EXISTS recipes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  cover_image VARCHAR(255),
  category_id INT,
  difficulty ENUM('简单', '中等', '困难') DEFAULT '简单',
  cook_time INT DEFAULT 30,
  servings INT DEFAULT 2,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (category_id) REFERENCES categories(id),
  INDEX idx_category (category_id),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 错误处理中间件

```typescript
// src/middleware/error-handler.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    // 记录详细错误日志
    console.error('=== 500 错误详情 ===');
    console.error('URL:', request.url);
    console.error('Method:', request.method);
    console.error('Error:', exception);
    console.error('Stack:', exception.stack);
    console.error('==================');

    // 返回友好的错误信息
    response.status(500).json({
      statusCode: 500,
      message: process.env.NODE_ENV === 'production' 
        ? 'Internal server error'
        : exception.message,  // 开发环境返回详细错误
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
```

### 健康检查接口

```typescript
// src/health/health.controller.ts
@Controller('health')
export class HealthController {
  constructor(private db: DatabaseService) {}

  @Get()
  async check() {
    try {
      // 测试数据库连接
      await this.db.query('SELECT 1');
      
      return {
        status: 'ok',
        database: 'connected',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        status: 'error',
        database: 'disconnected',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
}
```

---

## 📞 下一步行动

### 对于前端开发者（你）

✅ **前端工作已完成**，无需修改

你可以：
1. 继续开发其他功能（不依赖后端的功能）
2. 使用备用数据测试 UI/UX
3. 等待后端修复

### 对于后端开发者

❌ **需要修复后端接口**

优先级：
1. **立即**：查看云托管日志，找到具体错误原因
2. **立即**：检查数据库连接和表结构
3. **立即**：实现 `/api/v1/categories` 接口
4. **今天**：实现 `/api/v1/recipes` 接口
5. **本周**：实现其他核心接口

### 调试建议

**后端开发者可以这样调试**：

```typescript
// 在接口中添加详细日志
@Get('categories')
async getCategories() {
  console.log('=== 开始获取分类列表 ===');
  
  try {
    console.log('1. 连接数据库...');
    const connection = await this.db.getConnection();
    console.log('✅ 数据库连接成功');
    
    console.log('2. 查询分类...');
    const categories = await this.db.query('SELECT * FROM categories');
    console.log(`✅ 查询成功，找到 ${categories.length} 条分类`);
    
    console.log('3. 返回数据...');
    return {
      code: 200,
      message: 'success',
      data: categories
    };
  } catch (error) {
    console.error('❌ 错误发生在：', error.message);
    console.error('❌ 错误堆栈：', error.stack);
    throw error;
  }
}
```

---

## 🎉 总结

### 当前情况

| 方面 | 状态 | 说明 |
|------|------|------|
| **前端** | ✅ 完成 | URL 正确，容错机制正常 |
| **网络** | ✅ 正常 | 能访问后端服务 |
| **后端** | ❌ 500 错误 | 需要查看日志诊断 |

### 不影响使用

虽然后端有错误，但：
- ✅ 前端有备用数据，页面正常显示
- ✅ 本地功能正常（收藏、搜索、草稿等）
- ✅ 用户体验不受严重影响

### 下一步

1. **查看后端日志**（最重要！）
2. **检查数据库配置**
3. **确认表结构存在**
4. **如需帮助，联系后端开发者**

---

**前端已经尽力了！现在是后端的回合了！** 💪

