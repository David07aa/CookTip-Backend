# ✅ 搜索功能最终修复 - 参数类型错误

**修复时间**: 2025-10-30  
**Commit**: `0b50175`  
**状态**: 已修复

---

## 🎯 问题根源

### 错误信息

```
Provided "skip" value is not a number. Please provide a numeric value.
```

### 根本原因

**HTTP 查询参数都是字符串类型！**

前端通过 URL 传递的参数：
```
GET /api/v1/search/recipes?keyword=鸡&page=1&limit=10
```

在后端接收时：
```typescript
@Query('page') page: number = 1  // TypeScript 声明为 number
```

但实际上，`page` 的值是字符串 `"1"`，而不是数字 `1`！

导致：
```typescript
const skip = (page - 1) * limit;  // ("1" - 1) * "10" = NaN
```

TypeORM 的 `.skip(NaN)` 抛出错误：
```
Provided "skip" value is not a number
```

---

## ✅ 修复方案

### 1. 在 Service 中添加类型转换

**文件**: `src/modules/search/search.service.ts`

```typescript
async searchRecipes(
  keyword: string,
  page: number = 1,
  limit: number = 10,
  ...
) {
  try {
    // ✅ 确保 page 和 limit 是数字类型
    const pageNum = Number(page) || 1;
    const limitNum = Number(limit) || 10;
    const skip = (pageNum - 1) * limitNum;

    const queryBuilder = this.recipeRepository
      .createQueryBuilder('recipe')
      ...
      .skip(skip)          // ✅ 现在是数字
      .take(limitNum);     // ✅ 现在是数字

    return {
      items: [...],
      total,
      page: pageNum,        // ✅ 返回数字
      limit: limitNum,      // ✅ 返回数字
      total_pages: Math.ceil(total / limitNum),
    };
  }
}
```

### 2. 在 Controller 中也添加类型转换

**文件**: `src/modules/search/search.controller.ts`

```typescript
async searchRecipes(
  @Query('keyword') keyword: string,
  @Query('page') page: number = 1,
  @Query('limit') limit: number = 10,
  @Query('category_id') categoryId?: number,
  ...
) {
  // ✅ 确保查询参数是正确的数字类型（URL查询参数都是字符串）
  const pageNum = Number(page) || 1;
  const limitNum = Number(limit) || 10;
  const categoryIdNum = categoryId ? Number(categoryId) : undefined;

  console.log('[SearchController] Received request:', {
    keyword,
    page: pageNum,        // ✅ 记录转换后的数字
    limit: limitNum,
    categoryId: categoryIdNum,
    ...
  });

  const result = await this.searchService.searchRecipes(
    keyword,
    pageNum,          // ✅ 传递数字
    limitNum,         // ✅ 传递数字
    categoryIdNum,
    ...
  );
}
```

---

## 🔍 为什么之前没有发现？

### 可能的原因

1. **前端之前没有调用过搜索功能**
   - 第一次真正测试搜索
   - 之前的测试可能只是打开页面，没有实际搜索

2. **TypeScript 的类型声明不够严格**
   - `@Query('page') page: number` 只是类型声明
   - 实际运行时，Express/NestJS 不会自动转换类型
   - 查询参数始终是字符串

3. **NestJS 的 ValidationPipe 配置**
   - 虽然启用了 `ValidationPipe`，但 `@Query` 装饰器本身不会自动转换类型
   - 需要使用 `ParseIntPipe` 或手动转换

---

## 📚 最佳实践（NestJS）

### 方法 A: 使用 ParseIntPipe（推荐）

```typescript
async searchRecipes(
  @Query('page', new ParseIntPipe({ optional: true })) page: number = 1,
  @Query('limit', new ParseIntPipe({ optional: true })) limit: number = 10,
) {
  // page 和 limit 已经是数字类型
}
```

### 方法 B: 使用 DTO + class-transformer

```typescript
import { Type } from 'class-transformer';
import { IsInt, Min, Max, IsOptional } from 'class-validator';

export class SearchRecipesDto {
  keyword: string;

  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)  // ✅ 自动转换为数字
  page?: number = 1;

  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  @Type(() => Number)  // ✅ 自动转换为数字
  limit?: number = 10;
}

async searchRecipes(@Query() query: SearchRecipesDto) {
  // query.page 和 query.limit 已经是数字
}
```

### 方法 C: 手动转换（本次采用）

```typescript
const pageNum = Number(page) || 1;
const limitNum = Number(limit) || 10;
```

**优点**: 简单直接，容错性好  
**缺点**: 需要在每个方法中手动转换

---

## 🚀 部署和测试

### 部署状态

- ✅ 代码已推送到 GitHub（Commit: `0b50175`）
- ⏱️ 等待云托管自动部署（3-5 分钟）

### 测试步骤

1. **等待 3-5 分钟**

2. **打开小程序搜索页面**

3. **输入关键词搜索**（如"鸡"）

4. **预期结果**:
   ```
   云函数响应: {
     statusCode: 200,
     data: {
       items: [...],  // 搜索结果
       total: 10,
       page: 1,
       limit: 10
     }
   }
   ```

---

## 📊 完整修复历史

| 版本 | Commit | 修复内容 | 结果 |
|------|--------|----------|------|
| v1 | `3cfbf84` | user 空值检查 | ❌ 仍然 500 |
| v2 | `e554d37` | 所有字段添加默认值 | ❌ 仍然 500 |
| v3 | `375d110` | 显式 select + 排除 JSON 字段 | ❌ 仍然 500 |
| v4 | `ed9231e` | 全局异常过滤器 + 日志拦截器 | ✅ **看到具体错误** |
| **v5** | **`0b50175`** | **参数类型转换** | ✅ **应该成功** |

---

## 💡 经验教训

### 1. 全局异常过滤器至关重要

如果没有 `AllExceptionsFilter` 和 `LoggingInterceptor`，我们永远看不到具体的错误信息：
```
Provided "skip" value is not a number
```

**教训**: 在开发初期就应该添加完善的日志和异常处理。

### 2. TypeScript 类型声明 ≠ 运行时类型

```typescript
@Query('page') page: number = 1
```

这只是 TypeScript 的编译时类型检查，运行时 `page` 仍然是字符串。

**教训**: 不要依赖 TypeScript 的类型声明，需要显式转换或验证。

### 3. HTTP 查询参数都是字符串

无论前端如何传递，后端接收到的查询参数都是字符串：
```
?page=1 → page: "1"
?limit=10 → limit: "10"
?active=true → active: "true"
```

**教训**: 始终要转换查询参数的类型。

---

## 🎯 后续优化建议

### 1. 创建统一的 DTO

```typescript
// src/modules/search/dto/search-recipes.dto.ts
import { Type } from 'class-transformer';
import { IsString, IsInt, Min, Max, IsOptional, IsEnum } from 'class-validator';

export class SearchRecipesDto {
  @IsString()
  keyword: string;

  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;

  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  @Type(() => Number)
  limit?: number = 10;

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  categoryId?: number;

  @IsOptional()
  @IsString()
  difficulty?: string;

  @IsOptional()
  @IsEnum(['latest', 'hot', 'popular'])
  sort?: string = 'latest';
}
```

### 2. 使用 DTO 替换现有参数

```typescript
@Get('recipes')
async searchRecipes(@Query() dto: SearchRecipesDto) {
  // dto.page 和 dto.limit 已经是数字类型
  return this.searchService.searchRecipes(
    dto.keyword,
    dto.page,
    dto.limit,
    dto.categoryId,
    dto.difficulty,
    dto.sort,
  );
}
```

---

## ✅ 修复完成

**问题**: HTTP 查询参数是字符串，导致 TypeORM `.skip()` 和 `.take()` 报错

**解决**: 在 Service 和 Controller 中添加 `Number()` 转换

**状态**: 已修复并推送

**测试**: 等待 3-5 分钟后测试

---

**修复已完成！这次应该能成功了！** 🎉

**等待 3-5 分钟后，请再次测试搜索功能！** 🚀

